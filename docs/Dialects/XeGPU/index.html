<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'xegpu' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/XeGPU/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&amp;list_id=177877&amp;order=changeddate%20DESC%2Cpriority%2Cbug_severity&amp;product=MLIR&amp;query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'xegpu' Dialect</h1><p>The XeGPU dialect that models Intel GPU&rsquo;s ISA
The XeGPU dialect models Intel Xe ISA semantics but works at vector and
TensorDesc data type. It provides 1:1 mappings to match Xe instructions
like DPAS and 2D block load. The matrix size being processed at this level
exactly matches the hardware instructions or the intrinsic supported by
the lower-level GPU compiler.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#xegpualloc_nbarrier-xegpuallocnbarrierop><code>xegpu.alloc_nbarrier</code> (xegpu::AllocNbarrierOp)</a></li><li><a href=#xegpuatomic_rmw-xegpuatomicrmwop><code>xegpu.atomic_rmw</code> (xegpu::AtomicRMWOp)</a></li><li><a href=#xegpucreate_nd_tdesc-xegpucreatenddescop><code>xegpu.create_nd_tdesc</code> (xegpu::CreateNdDescOp)</a></li><li><a href=#xegpucreate_tdesc-xegpucreatedescop><code>xegpu.create_tdesc</code> (xegpu::CreateDescOp)</a></li><li><a href=#xegpudpas-xegpudpasop><code>xegpu.dpas</code> (xegpu::DpasOp)</a></li><li><a href=#xegpufence-xegpufenceop><code>xegpu.fence</code> (xegpu::FenceOp)</a></li><li><a href=#xegpuinit_nbarrier-xegpuinitnbarrierop><code>xegpu.init_nbarrier</code> (xegpu::InitNbarrierOp)</a></li><li><a href=#xegpuload-xegpuloadgatherop><code>xegpu.load</code> (xegpu::LoadGatherOp)</a></li><li><a href=#xegpuload_nd-xegpuloadndop><code>xegpu.load_nd</code> (xegpu::LoadNdOp)</a></li><li><a href=#xegpunbarrier_arrive-xegpunbarrierarriveop><code>xegpu.nbarrier_arrive</code> (xegpu::NbarrierArriveOp)</a></li><li><a href=#xegpunbarrier_wait-xegpunbarrierwaitop><code>xegpu.nbarrier_wait</code> (xegpu::NbarrierWaitOp)</a></li><li><a href=#xegpuprefetch-xegpuprefetchop><code>xegpu.prefetch</code> (xegpu::PrefetchOp)</a></li><li><a href=#xegpuprefetch_nd-xegpuprefetchndop><code>xegpu.prefetch_nd</code> (xegpu::PrefetchNdOp)</a></li><li><a href=#xegpustore-xegpustorescatterop><code>xegpu.store</code> (xegpu::StoreScatterOp)</a></li><li><a href=#xegpustore_nd-xegpustorendop><code>xegpu.store_nd</code> (xegpu::StoreNdOp)</a></li><li><a href=#xegpuupdate_nd_offset-xegpuupdatendoffsetop><code>xegpu.update_nd_offset</code> (xegpu::UpdateNdOffsetOp)</a></li><li><a href=#xegpuupdate_offset-xegpuupdateoffsetop><code>xegpu.update_offset</code> (xegpu::UpdateOffsetOp)</a></li></ul></li><li><a href=#attributes-13>Attributes</a><ul><li><a href=#cachepolicyattr>CachePolicyAttr</a></li><li><a href=#fencescopeattr>FenceScopeAttr</a></li><li><a href=#memoryscopeattr>MemoryScopeAttr</a></li><li><a href=#tensordescattr>TensorDescAttr</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#nbarriertype>NbarrierType</a></li><li><a href=#tensordesctype>TensorDescType</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/XeGPU/IR/XeGPU.td>source</a></p><h3 id=xegpualloc_nbarrier-xegpuallocnbarrierop><code>xegpu.alloc_nbarrier</code> (xegpu::AllocNbarrierOp)&nbsp;<a class=headline-hash href=#xegpualloc_nbarrier-xegpuallocnbarrierop>¶</a></h3><p><em>It allocates a set of named barriers.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xegpu.alloc_nbarrier` $nbarrier_num attr-dict
</code></pre><p>AllocNbarrier is to create a set of named barriers as
specified by <code>nbarrier_num</code>. Named barriers are workgroup level resources,
and are shared by all threads in the workgroup. For example, there are
up to 32 barriers (range 0-31) for each XeCore on PVC. A typical use case
is that a workgroup is partitioned into N subgroups of threads (N &lt;= 32),
and each subgroup coordinating their work with a separate barrier with id
range from 0 to N respectively.</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>nbarrier_num</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h3 id=xegpuatomic_rmw-xegpuatomicrmwop><code>xegpu.atomic_rmw</code> (xegpu::AtomicRMWOp)&nbsp;<a class=headline-hash href=#xegpuatomic_rmw-xegpuatomicrmwop>¶</a></h3><p><em>Atomic ready-modify-write operation on the TensorDesc.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xegpu.atomic_rmw` $kind $tensorDesc `,` $mask `,` $value attr-dict `:`
              type($tensorDesc) `,` type($mask) `,` type($value) `-&gt;` type($result)
</code></pre><p>The <code>xegpu.atomic_rmw</code> operation provides a way to perform a read-modify-write
operation on the region described by the <code>TensorDesc</code> free from data races. The
<code>kind</code> enumeration specifies the modification to be performed, The <code>mask</code> operand
has the same shape with <code>TensorDesc</code>, and is used to enable or disable specific
data points of the <code>TensorDesc</code>. The <code>value</code> operand represents the new value to
be applied during the modification.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>kind</code></td><td>::mlir::arith::AtomicRMWKindAttr</td><td><details><summary>allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14</summary><p>Enum cases:</p><ul><li>addf (<code>addf</code>)</li><li>addi (<code>addi</code>)</li><li>assign (<code>assign</code>)</li><li>maximumf (<code>maximumf</code>)</li><li>maxs (<code>maxs</code>)</li><li>maxu (<code>maxu</code>)</li><li>minimumf (<code>minimumf</code>)</li><li>mins (<code>mins</code>)</li><li>minu (<code>minu</code>)</li><li>mulf (<code>mulf</code>)</li><li>muli (<code>muli</code>)</li><li>ori (<code>ori</code>)</li><li>andi (<code>andi</code>)</li><li>maxnumf (<code>maxnumf</code>)</li><li>minnumf (<code>minnumf</code>)</li></ul></details></td></tr></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tensorDesc</code></td><td>TensorDesc describing regions of interested data.</td></tr><tr><td style=text-align:center><code>mask</code></td><td>vector of 1-bit signless integer values of ranks 1/2 or 1-bit signless integer</td></tr><tr><td style=text-align:center><code>value</code></td><td>vector of 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type values of ranks 1/2/3/4 or 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector of 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type values of ranks 1/2/3/4 or 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type</td></tr></tbody></table><h3 id=xegpucreate_nd_tdesc-xegpucreatenddescop><code>xegpu.create_nd_tdesc</code> (xegpu::CreateNdDescOp)&nbsp;<a class=headline-hash href=#xegpucreate_nd_tdesc-xegpucreatenddescop>¶</a></h3><p><em>Create nd-tensor descriptor operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xegpu.create_nd_tdesc` $source ``
              custom&lt;DynamicIndexList&gt;($offsets, $const_offsets)
              (`,` custom&lt;DynamicIndexList&gt;($shape, $const_shape)^
              `,` custom&lt;DynamicIndexList&gt;($strides, $const_strides))?
              attr-dict `:` type($source) `-&gt;` qualified(type($TensorDesc))
</code></pre><p>The &ldquo;create_nd_tdesc&rdquo; operation creates a TensorDescType which represents
a sub-view of a 2D memory region (It can be extended to support n-D memory
region if needed in future). Elements in the subview continuous in each
dimension. It encodes the following important information for supporting
Intel hardware features:</p><ul><li>source: an object representing (starting address/pointer of) a 2D memory region.
It can be either a 2D memref object, or simply a pointer represented by uint64_t type.
for the later case, the shape and layout information of the 2D memory region should
be explicitly passed via <code>shape</code> and <code>strides</code> parameters.</li><li>offsets: two index values represents offsets from the &ldquo;source&rdquo; at the each dimension
at which the subview of the target memory will be created. It is encoded via two
variables, including &ldquo;offsets&rdquo; and &ldquo;const_offsets&rdquo;, such that it can
accept various forms, such as, operands (e.g., [%c0, %c]) and attributes (e.g., [2, 4]).</li><li>shape: the shape information of the memory region pointed by the &ldquo;source&rdquo;. It is
typically encoded via the MemRefType of the source, e.g., memref&lt;4096x4096xf16>.
But if &ldquo;source&rdquo; is simply a pointer represented as uint64_t type, or a memref
type without shape information e.g., memref&lt;?x?xf16>, the shape information has
to be explicitly passed via the &ldquo;shape&rdquo; and &ldquo;const_shape&rdquo; arguments.</li><li>strides: the strides of the memory region pointed by the &ldquo;source&rdquo;. Similar to shape,
it is typically encoded via the MemRefType of the source too. But if &ldquo;source&rdquo; is
simply a pointer represented as uint64_t type, or a memref type without shape
information e.g., memref&lt;?x?xf16>, the strides information has to be explicitly
passed via the &ldquo;strides&rdquo; and &ldquo;const_strides&rdquo; argument.</li></ul><p>Example 1 (suppose the tensor shape inferred by the compiler is 8x16):
%0 = memref.alloc() : memref&lt;1024x1024xf32>
%c0 = arith.constant 0 : index
%c1 = arith.constant 1 : index
%1 = xegpu.create_nd_tdesc %0[%c0, %c0]: memref&lt;1024x1024xf32> -> TensorDesc&lt;8x16xf32></p><p>Example 2 (suppose the tensor shape inferred by the compiler is 8x16):
%0 = memref.alloc(%h, %w) : memref&lt;?x?xf32>
%c0 = arith.constant 0 : index
%c1 = arith.constant 1 : index
%1 = xegpu.create_nd_tdesc %0[%c0, %c0], [%h, %w], [%w, %c1]: memref&lt;?x?xf32> -> TensorDesc&lt;8x16xf32></p><p>Example 3 (suppose the tensor shape inferred by the compiler is 8x16):
%0 = &mldr; : ui64
%c0 = arith.constant 0 : index
%c1 = arith.constant 1 : index
%1 = xegpu.create_nd_tdesc %0[%c0, %c0], [%h, %w], [%w, %c1]: ui64 -> TensorDesc&lt;8x16xf32></p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OffsetSizeAndStrideOpInterface</code>, <code>ViewLikeOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>const_offsets</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr><tr><td><code>const_shape</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr><tr><td><code>const_strides</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>source</code></td><td>1D/2D memref of 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type values or 64-bit unsigned integer or 32-bit unsigned integer or 64-bit signless integer or 32-bit signless integer</td></tr><tr><td style=text-align:center><code>offsets</code></td><td>variadic of index</td></tr><tr><td style=text-align:center><code>shape</code></td><td>variadic of index</td></tr><tr><td style=text-align:center><code>strides</code></td><td>variadic of index</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>TensorDesc</code></td><td>TensorDesc describing regions of interested data.</td></tr></tbody></table><h3 id=xegpucreate_tdesc-xegpucreatedescop><code>xegpu.create_tdesc</code> (xegpu::CreateDescOp)&nbsp;<a class=headline-hash href=#xegpucreate_tdesc-xegpucreatedescop>¶</a></h3><p><em>Create scattered tensor descriptors (TensorDesc).</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xegpu.create_tdesc` $source
              custom&lt;DynamicIndexList&gt;($offsets, $const_offsets)
              attr-dict `:`  type($source) `-&gt;` qualified(type($TensorDesc))
</code></pre><p>&ldquo;create_tdesc&rdquo; is similar to &ldquo;create_nd_tdesc&rdquo; in terms that it creates
a Tensor Descriptor (TensorDescType) for a memory region. While &ldquo;create_nd_tdesc&rdquo;
is for creating continuous subviews, &ldquo;create_tdesc&rdquo; is for creating non-continuous
(scattered) subviews, allowing each work-item in a subgroup specifying their own offset.
It accepts the following parameters:</p><ul><li>source: a 1D memref or pointer (uint64_t) represents the flattened memory object.</li><li>offsets: a array containing offsets of each access point. Its size
is fixed to the hardware supportted subgroup size, e.g., 16 on PVC,
implying each element in the array corresponds to a work-item (SIMT lane)
in the subgroup.</li><li>chunk_size: [optional attribute] indicates number of continious
elements accessed for each offset, default is 1.</li></ul><p>Example 1. It assumes subgroup size is 4, and accesses a[0], a[16], a[32], a[64]</p><pre tabindex=0><code>%a = memref.alloc() : memref&lt;1024xf32&gt;
%1 = xegpu.create_tdesc %a[0, 16, 32, 64]: memref&lt;1024xf32&gt; -&gt; TensorDesc&lt;4xf32&gt;
</code></pre><p>Example 2. It assumes subgroup size is 4, and each workitem access 8 elements.
It will access totally 32 data elements: a[0:7], a[16:23], a[32:39], a[64:71]</p><pre tabindex=0><code>%0 = memref.alloc() : memref&lt;1024xf32&gt;
%1 = xegpu.create_tdesc %0[0, 16, 32, 64] {chunk_size = 8}: memref&lt;1024xf32&gt; -&gt; TensorDesc&lt;4x8xf32&gt;
</code></pre><p>Example 3. It is similar to Example 2, but there is some overlaps among workitems.
It accesses: a[0:7], a[4:11], a[8:15], a[12:19]</p><pre tabindex=0><code>%0 = memref.alloc() : memref&lt;1024xf32&gt;
%1 = xegpu.create_tdesc %0[0, 4, 8, 12] {chunk_size = 8}: memref&lt;1024xf32&gt; -&gt; TensorDesc&lt;4x8xf32&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>ViewLikeOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>const_offsets</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr><tr><td><code>chunk_size</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>source</code></td><td>1D/2D memref of 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type values or 64-bit unsigned integer or 32-bit unsigned integer or 64-bit signless integer or 32-bit signless integer</td></tr><tr><td style=text-align:center><code>offsets</code></td><td>variadic of index</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>TensorDesc</code></td><td>TensorDesc describing regions of interested data.</td></tr></tbody></table><h3 id=xegpudpas-xegpudpasop><code>xegpu.dpas</code> (xegpu::DpasOp)&nbsp;<a class=headline-hash href=#xegpudpas-xegpudpasop>¶</a></h3><p><em>It performs mma computation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xegpu.dpas` $lhs `,` $rhs (`,` $acc^)? attr-dict `:` type($lhs)`,` type($rhs) (`,` type($acc)^)?  `-&gt;` type($result)
</code></pre><p>DPAS performs matrix multiplication on matrix A of <code>mxk</code>
size, B of <code>kxn</code> size, and accumulate on matrix C of <code>mxn</code> to the same size
matrix , <code>m=8</code>, <code>n=16</code> and <code>k=8 * 32/bit_width_of_elem_type</code>. So for fp16
data type, the matrices are <code>A: vector&lt;8x16xf16></code>, <code>B: vector&lt;16x16xf16></code>,
and <code>C/D: vector&lt;8x16xf32></code>. Besides the matrix size requirements, DPAS
also requires A and B to be loaded with the required data layout. Specially,
VNNI layout is required for B operand. It is achieved via setting <code>vnni_axis = 0</code>
of the corresponding <code>load_nd</code> operator. To keep both operands as 3D vector,
operand A is loaded via setting <code>vnni_axis = 1</code> without impacting the
physical layouts change in register. Due to the VNNI transformation, A and B operands
are represented as 3D vector, with the last dimension representing the VNNI factor,
which is computed as <code>32/bit_width_of_elem_type</code>. Therefore, <code>A: vector&lt;8x16xf16></code>
is represented as <code>A: vector&lt;8x8x2xf16></code>, and <code>B: vector&lt;16x16xf16></code> is
represented as <code>B: vector&lt;8x16x2xf16></code>.</p><pre><code>Note: on PVC, the hardware can perform load with VNNI transformation when data
      element type is 16-bit or lower precision, taking 2 or 4 elements from
      the first dimension and inserted into the newly added innermost dimension.
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>vector of 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type values of ranks 2/3</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>vector of 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type values of ranks 2/3</td></tr><tr><td style=text-align:center><code>acc</code></td><td>vector of 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type values of ranks 2</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector of 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type values of ranks 2</td></tr></tbody></table><h3 id=xegpufence-xegpufenceop><code>xegpu.fence</code> (xegpu::FenceOp)&nbsp;<a class=headline-hash href=#xegpufence-xegpufenceop>¶</a></h3><p><em>It synchronizes memory accesses.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xegpu.fence` `memory_kind` `=` `` $memory_kind `,` `fence_scope` `=` `` $fence_scope attr-dict
</code></pre><p>It synchronizes the memory access between
write and following read or write.
1. <code>Memory_kind</code> describes the memory kind. &ldquo;global&rdquo; means the global memory,
&ldquo;slm&rdquo; means the share local memory.
2. <code>Fence_scope</code> describes the scope of fence. &ldquo;Workgroup&rdquo; means that the scope would be
within each workgroup. &ldquo;GPU&rdquo; means the scope would be across workgroups within the GPU.</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_kind</code></td><td>::mlir::xegpu::MemoryScopeAttr</td><td><details><summary>Describe the location of data described by a `TensorDesc`:
Global device memory (`Global`) or Shared local memory (`SLM`).</summary><p>Enum cases:</p><ul><li>global (<code>Global</code>)</li><li>slm (<code>SLM</code>)</li></ul></details></td></tr><tr><td><code>fence_scope</code></td><td>::mlir::xegpu::FenceScopeAttr</td><td><details><summary>Describes the scope of fence.
"workgroup" means that the scope is within each work group.
"gpu" means the scope is across work groups within the gpu.</summary><p>Enum cases:</p><ul><li>workgroup (<code>Workgroup</code>)</li><li>gpu (<code>GPU</code>)</li></ul></details></td></tr></table><h3 id=xegpuinit_nbarrier-xegpuinitnbarrierop><code>xegpu.init_nbarrier</code> (xegpu::InitNbarrierOp)&nbsp;<a class=headline-hash href=#xegpuinit_nbarrier-xegpuinitnbarrierop>¶</a></h3><p><em>It assigns a named barrier to the current thread.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xegpu.init_nbarrier` $nbarrier_id `,` $participant_thread_num attr-dict `:`
              type($nbarrier_id) `,` type($participant_thread_num) `-&gt;` qualified(type($result))
</code></pre><p>InitNbarrierOp assigns the named barrier with the specified
barrier ID (0~31) to the current thread. Multiple threads may bind to the
same named barrier, and the <code>participant_thread_num</code> specifies the total
number of threads associated with the nbarrier. It returns an object of
NbarrierType representing the barrier</p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>nbarrier_id</code></td><td>8-bit signless integer</td></tr><tr><td style=text-align:center><code>participant_thread_num</code></td><td>8-bit signless integer</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>!xegpu.nbarrier a custom XeGPU type representing a barrier.</td></tr></tbody></table><h3 id=xegpuload-xegpuloadgatherop><code>xegpu.load</code> (xegpu::LoadGatherOp)&nbsp;<a class=headline-hash href=#xegpuload-xegpuloadgatherop>¶</a></h3><p><em>Load a set of scattered data points from memory.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xegpu.load` $TensorDesc `,` $mask prop-dict attr-dict
              `:` qualified(type($TensorDesc)) `,` type($mask) `-&gt;` type($value)
</code></pre><p>It (aka. load) load data per each work-item. The output
describes the data being loaded at the subgroup level, so its size is
consistent with the number of work-items in a subgroup. When <code>chunk_size_per_lane</code>
attribute is larger than 1 in TensorDesc, the output vector will be 2D vector,
with dim-1 correspoding to the chunk size.</p><p>The mask operand masks out memory access so that it is safe to pass out-of-boundary
addresses/offsets as long as they are masked. It applies to slots of SIMD lanes.</p><p>Example:</p><pre tabindex=0><code>  %2 = xegpu.load %1, %0 {transpose = [1, 0],
                          l1_hint = #xegpu.cache_hint&lt;cached&gt;,
                          l2_hint = #xegpu.cache_hint&lt;uncached&gt;,
                          l3_hint = #xegpu.cache_hint&lt;uncached&gt;}
        : !xegpu.tensor_desc&lt;16xf32, #xegpu.tdesc_attr&lt;scattered=true&gt;&gt;, vector&lt;16xi1&gt;
          -&gt; vector&lt;16xf32&gt;
</code></pre><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>transpose</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr><tr><td><code>l1_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr><tr><td><code>l2_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr><tr><td><code>l3_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>TensorDesc</code></td><td>TensorDesc describing regions of interested data.</td></tr><tr><td style=text-align:center><code>mask</code></td><td>vector of 1-bit signless integer values of ranks 1/2 or 1-bit signless integer</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>vector of 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type values of ranks 1/2/3/4 or 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type</td></tr></tbody></table><h3 id=xegpuload_nd-xegpuloadndop><code>xegpu.load_nd</code> (xegpu::LoadNdOp)&nbsp;<a class=headline-hash href=#xegpuload_nd-xegpuloadndop>¶</a></h3><p><em>Loads a n-D block from memory (represented by TensorDesc)to registers (represented by vector)</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xegpu.load_nd` $TensorDesc prop-dict attr-dict `:` qualified(type($TensorDesc)) `-&gt;` type($value)
</code></pre><p>LoadNdOp essentially mimics the hardware block read instruction to read
a block of data from memory to register. It takes a set of optional cache
hints for each level of cache, L1, L2 and L3. If hardware does not have a
correspoding cache, Corresponding cache hint attribute will be masked.
VNNI transformation is an hardware feature for Intel GPU, which is used to
do data packing during the load for B operand of matrix operation, if
the bit width of the data type is less then 32 bits, e.g., fp16. And
transpose is another Intel hardware feature, which will do transpose
operation when loading the data if the bit width of the data type is
fp32 or fp64. It implies that vnni and transpose cannot exit at the
same time.</p><p>Example:</p><pre tabindex=0><code>  xegpu.load_nd %1 {transpose = [1, 0],
                    l1_hint = #xegpu.cache_hint&lt;cached&gt;,
                    l2_hint = #xegpu.cache_hint&lt;uncached&gt;,
                    l3_hint = #xegpu.cache_hint&lt;streaming&gt;}
          : !xegpu.tensor_desc&lt;8x16xf32&gt; -&gt; vector&lt;16x8xf32&gt;
</code></pre><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>vnni_axis</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>transpose</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr><tr><td><code>l1_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr><tr><td><code>l2_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr><tr><td><code>l3_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>TensorDesc</code></td><td>TensorDesc describing regions of interested data.</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>vector of 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type values of ranks 1/2/3/4 or 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type</td></tr></tbody></table><h3 id=xegpunbarrier_arrive-xegpunbarrierarriveop><code>xegpu.nbarrier_arrive</code> (xegpu::NbarrierArriveOp)&nbsp;<a class=headline-hash href=#xegpunbarrier_arrive-xegpunbarrierarriveop>¶</a></h3><p><em>It signals the arrival at the named barrier.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xegpu.nbarrier_arrive` $nbarrier attr-dict `:` qualified(type($nbarrier))
</code></pre><p>NbarrierArriveOp signals the hardware (or other threads)
that the current thread has produced its data for the consumer threads. When
the hardware signalled by <code>participant_thread_num</code> threads for the named barrier,
it will notify the threads waiting for the named barrier to continue their work.</p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>nbarrier</code></td><td>!xegpu.nbarrier a custom XeGPU type representing a barrier.</td></tr></tbody></table><h3 id=xegpunbarrier_wait-xegpunbarrierwaitop><code>xegpu.nbarrier_wait</code> (xegpu::NbarrierWaitOp)&nbsp;<a class=headline-hash href=#xegpunbarrier_wait-xegpunbarrierwaitop>¶</a></h3><p><em>It waits for a named barrier.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xegpu.nbarrier_wait` $nbarrier attr-dict `:` qualified(type($nbarrier))
</code></pre><p>NbarrierWaitOp signals the hardware which named barrier
the current thread is waiting for, such that it can get notified when the
named barrier is completed.</p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>nbarrier</code></td><td>!xegpu.nbarrier a custom XeGPU type representing a barrier.</td></tr></tbody></table><h3 id=xegpuprefetch-xegpuprefetchop><code>xegpu.prefetch</code> (xegpu::PrefetchOp)&nbsp;<a class=headline-hash href=#xegpuprefetch-xegpuprefetchop>¶</a></h3><p><em>Prefetches a set of scattered data points to cache</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xegpu.prefetch` $TensorDesc prop-dict attr-dict `:` qualified(type($TensorDesc))
</code></pre><p>It issues instructions to prefetch a set of scattered data points
from memory to each level of the cache based on their cache policy.
As compared to prefetch_nd, which works on non-scattered TensorDesc,
it works on scattered TensorDesc instead.</p><p>Example:</p><pre tabindex=0><code>  xegpu.prefetch %tdesc {l1_hint = #xegpu.cache_hint&lt;cached&gt;,
                         l2_hint = #xegpu.cache_hint&lt;cached&gt;,
                         l3_hint = #xegpu.cache_hint&lt;cached&gt;}
    : !xegpu.tensor_desc&lt;16xf16&gt;
</code></pre><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>l1_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr><tr><td><code>l2_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr><tr><td><code>l3_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>TensorDesc</code></td><td>TensorDesc describing regions of interested data.</td></tr></tbody></table><h3 id=xegpuprefetch_nd-xegpuprefetchndop><code>xegpu.prefetch_nd</code> (xegpu::PrefetchNdOp)&nbsp;<a class=headline-hash href=#xegpuprefetch_nd-xegpuprefetchndop>¶</a></h3><p><em>Prefetches a n-D block to cache</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xegpu.prefetch_nd` $TensorDesc prop-dict attr-dict `:` qualified(type($TensorDesc))
</code></pre><p>It issues an instruction to prefetch a block of data from continuous
memory regions to each level of the cache based on their cache policy.</p><p>Example:</p><pre tabindex=0><code>  xegpu.prefetch_nd %tdesc {l1_hint = #xegpu.cache_hint&lt;cached&gt;,
                            l2_hint = #xegpu.cache_hint&lt;cached&gt;,
                            l3_hint = #xegpu.cache_hint&lt;cached&gt;}
    : !xegpu.tensor_desc&lt;8x16xf16&gt;
</code></pre><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>l1_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr><tr><td><code>l2_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr><tr><td><code>l3_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>TensorDesc</code></td><td>TensorDesc describing regions of interested data.</td></tr></tbody></table><h3 id=xegpustore-xegpustorescatterop><code>xegpu.store</code> (xegpu::StoreScatterOp)&nbsp;<a class=headline-hash href=#xegpustore-xegpustorescatterop>¶</a></h3><p><em>Store data to scattered memory locations.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xegpu.store` $value `,` $TensorDesc `,` $mask prop-dict attr-dict
              `:` type($value) `,` qualified(type($TensorDesc)) `,` type($mask)
</code></pre><p>It (aka. store) stores data to scattered memory locations.
It has similar semantic to <code>load_gather</code>.</p><p>Example:</p><pre tabindex=0><code>  %3 = xegpu.store %0, %1, %2 {l1_hint = #xegpu.cache_hint&lt;uncached&gt;,
                               l2_hint = #xegpu.cache_hint&lt;write_back&gt;,
                               l3_hint = #xegpu.cache_hint&lt;write_through&gt;}
        : vector&lt;16xf32&gt;, !xegpu.tensor_desc&lt;16xf32, #xegpu.tdesc_attr&lt;scattered=true&gt;&gt;, vector&lt;16xi1&gt;
</code></pre><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>l1_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr><tr><td><code>l2_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr><tr><td><code>l3_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>vector of 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type values of ranks 1/2/3/4 or 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type</td></tr><tr><td style=text-align:center><code>TensorDesc</code></td><td>TensorDesc describing regions of interested data.</td></tr><tr><td style=text-align:center><code>mask</code></td><td>vector of 1-bit signless integer values of ranks 1/2 or 1-bit signless integer</td></tr></tbody></table><h3 id=xegpustore_nd-xegpustorendop><code>xegpu.store_nd</code> (xegpu::StoreNdOp)&nbsp;<a class=headline-hash href=#xegpustore_nd-xegpustorendop>¶</a></h3><p><em>Stores a n-D block register region back to memory, currently only supports 2D</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xegpu.store_nd` $value `,` $TensorDesc prop-dict attr-dict
              `:` type($value) `,` qualified(type($TensorDesc))
</code></pre><p>StoreNdOp essentially mimics the hardware block write instruction io
write a block of data from register into the memory region as described
by the TensorDesc. It takes a set of optional cache hints for each level
of cache, L1, L2 and L3. If hardware does not have a correspoding cache,
Corresponding cache hint attribute will be masked.</p><p>Example:</p><pre tabindex=0><code>  xegpu.store_nd %3, %2 {l1_hint = #xegpu.cache_hint&lt;uncached&gt;,
                         l2_hint = #xegpu.cache_hint&lt;write_back&gt;,
                         l3_hint = #xegpu.cache_hint&lt;write_through&gt;}
                         : vector&lt;8x16xf16&gt;, !xegpu.tensor_desc&lt;8x16xf16&gt;
</code></pre><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>l1_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr><tr><td><code>l2_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr><tr><td><code>l3_hint</code></td><td>::mlir::xegpu::CachePolicyAttr</td><td><details><summary>Describe the cache settings for prefetch/load/store operators</summary><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul></details></td></tr></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>vector of 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type values of ranks 1/2/3/4 or 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 1-bit signed integer or 8-bit signed integer or 16-bit signed integer or 32-bit signed integer or 64-bit signed integer or 1-bit unsigned integer or 8-bit unsigned integer or 16-bit unsigned integer or 32-bit unsigned integer or 64-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or tf32 type</td></tr><tr><td style=text-align:center><code>TensorDesc</code></td><td>TensorDesc describing regions of interested data.</td></tr></tbody></table><h3 id=xegpuupdate_nd_offset-xegpuupdatendoffsetop><code>xegpu.update_nd_offset</code> (xegpu::UpdateNdOffsetOp)&nbsp;<a class=headline-hash href=#xegpuupdate_nd_offset-xegpuupdatendoffsetop>¶</a></h3><p><em>It updates the offsets for the TensorDesc.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xegpu.update_nd_offset` $TensorDesc `,`
              custom&lt;DynamicIndexList&gt;($offsets, $const_offsets)
              attr-dict `:` qualified(type($result))
</code></pre><p>The op updates the offset of the given TensorDesc.
The offsets are relative offset to the current position in the number
of elements. It will result in a same type TensorDesc as the input.</p><p>example:</p><pre tabindex=0><code>  %2 = xegpu.update_nd_offset %1, [0, 16]: !xegpu.tensor_desc&lt;8x16xf32&gt;
</code></pre><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>const_offsets</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr></table><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>TensorDesc</code></td><td>TensorDesc describing regions of interested data.</td></tr><tr><td style=text-align:center><code>offsets</code></td><td>variadic of index</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>TensorDesc describing regions of interested data.</td></tr></tbody></table><h3 id=xegpuupdate_offset-xegpuupdateoffsetop><code>xegpu.update_offset</code> (xegpu::UpdateOffsetOp)&nbsp;<a class=headline-hash href=#xegpuupdate_offset-xegpuupdateoffsetop>¶</a></h3><p><em>It updates the offsets for the given tensor descriptor</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xegpu.update_offset` $TensorDesc `,`
              custom&lt;DynamicIndexList&gt;($offsets, $const_offsets)
              attr-dict `:` qualified(type($TensorDesc))
</code></pre><p>It behaves similar to <code>update_nd_offset</code> in terms that
it updates offset of a TensorDesc, and the offsets are relative offset to
the current position in the number of elements. However, <code>update_nd_offset</code>
is to update the start point of a 2D block, so its offset constains two
elements representing the shift in each dimension. <code>update_offset</code> is to
update the offset per work-item, so its offsets contains values representing
shifts for each work-item.</p><pre><code>Example:
```
  %2 = xegpu.update_offset %1, [32, 32, 32, 32]
        : !xegpu.tensor_desc&lt;4x2xf32, #xegpu.tdesc_attr&lt;scattered = true&gt;&gt;
```
</code></pre><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>const_offsets</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>TensorDesc</code></td><td>TensorDesc describing regions of interested data.</td></tr><tr><td style=text-align:center><code>offsets</code></td><td>variadic of index</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>TensorDesc describing regions of interested data.</td></tr></tbody></table><h2 id=attributes-13>Attributes&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h2><h3 id=cachepolicyattr>CachePolicyAttr&nbsp;<a class=headline-hash href=#cachepolicyattr>¶</a></h3><p>Describe the cache settings for prefetch/load/store operators</p><p>Syntax:</p><pre tabindex=0><code>#xegpu.cache_hint&lt;
  ::mlir::xegpu::CachePolicy   # value
&gt;
</code></pre><p>Enum cases:</p><ul><li>cached (<code>CACHED</code>)</li><li>uncached (<code>UNCACHED</code>)</li><li>streaming (<code>STREAMING</code>)</li><li>read_invalidate (<code>READ_INVALIDATE</code>)</li><li>write_back (<code>WRITE_BACK</code>)</li><li>write_through (<code>WRITE_THROUGH</code>)</li></ul><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::xegpu::CachePolicy</code></td><td>an enum of type CachePolicy</td></tr></tbody></table><h3 id=fencescopeattr>FenceScopeAttr&nbsp;<a class=headline-hash href=#fencescopeattr>¶</a></h3><p>Describes the scope of fence.
&ldquo;workgroup&rdquo; means that the scope is within each work group.
&ldquo;gpu&rdquo; means the scope is across work groups within the gpu.</p><p>Syntax:</p><pre tabindex=0><code>#xegpu.fence_scope&lt;
  ::mlir::xegpu::FenceScope   # value
&gt;
</code></pre><p>Enum cases:</p><ul><li>workgroup (<code>Workgroup</code>)</li><li>gpu (<code>GPU</code>)</li></ul><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::xegpu::FenceScope</code></td><td>an enum of type FenceScope</td></tr></tbody></table><h3 id=memoryscopeattr>MemoryScopeAttr&nbsp;<a class=headline-hash href=#memoryscopeattr>¶</a></h3><p>Describe the location of data described by a <code>TensorDesc</code>:
Global device memory (<code>Global</code>) or Shared local memory (<code>SLM</code>).</p><p>Syntax:</p><pre tabindex=0><code>#xegpu.memory_scope&lt;
  ::mlir::xegpu::MemoryScope   # value
&gt;
</code></pre><p>Enum cases:</p><ul><li>global (<code>Global</code>)</li><li>slm (<code>SLM</code>)</li></ul><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::xegpu::MemoryScope</code></td><td>an enum of type MemoryScope</td></tr></tbody></table><h3 id=tensordescattr>TensorDescAttr&nbsp;<a class=headline-hash href=#tensordescattr>¶</a></h3><p>a composite attribute for <code>TensorDescType</code></p><p>Syntax:</p><pre tabindex=0><code>#xegpu.tdesc_attr&lt;
  MemoryScopeAttr,   # memory_scope
  IntegerAttr,   # array_length
  BoolAttr,   # boundary_check
  BoolAttr   # scattered
&gt;
</code></pre><p><code>TensorDescAttr</code> (or <code>tdesc_attr</code>) is a composite
attribute defined for <code>TensorDescType</code> for describing following
properties of a <code>TensorDesc</code>.
1. <code>memory_scope</code>: It describes where the data block described by the
TensorDesc is located, <code>Global</code> device memory or <code>Shared</code> local memory.
It is default to <code>Global</code>.
2. <code>array_length</code>: It describes how many horizontally consecutive blocks
will be loaded by a hardware load instruction. If the TensorDesc shape
is 8x16, with array_length = 2. The loaded block shape will be acctually
8x32. Its default value is 1.
3. <code>boundary_check</code>: It is used to indicates the hardware whether to do
out-of-boundary check. The default value is true.
4. <code>scattered</code>: It is used to differenciate TensorDescs created from
<code>create_nd_tdesc</code> vs from <code>create_tdesc</code>.</p><h4 id=parameters-3>Parameters:&nbsp;<a class=headline-hash href=#parameters-3>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>memory_scope</td><td style=text-align:center><code>MemoryScopeAttr</code></td><td></td></tr><tr><td style=text-align:center>array_length</td><td style=text-align:center><code>IntegerAttr</code></td><td>1</td></tr><tr><td style=text-align:center>boundary_check</td><td style=text-align:center><code>BoolAttr</code></td><td>true</td></tr><tr><td style=text-align:center>scattered</td><td style=text-align:center><code>BoolAttr</code></td><td>false</td></tr></tbody></table><h2 id=types>Types&nbsp;<a class=headline-hash href=#types>¶</a></h2><h3 id=nbarriertype>NbarrierType&nbsp;<a class=headline-hash href=#nbarriertype>¶</a></h3><p>!xegpu.nbarrier a custom XeGPU type representing a barrier.</p><p>Syntax: <code>!xegpu.nbarrier</code></p><h3 id=tensordesctype>TensorDescType&nbsp;<a class=headline-hash href=#tensordesctype>¶</a></h3><p>TensorDesc describing regions of interested data.</p><p>TensorDesc is a type designed to describe regions of the interested data as well as some
features that are unique to Intel hardware. Different with the builtin tensor type in MLIR,
it essentially only contains the meta data, and doesn&rsquo;t hold the data by itself. It is designed
to mainly support 2D block load/store and DPAS (matrix multiplication instruction) on Intel GPU.
It encodes the following information:</p><ul><li>shape: the sizes/shape of the intereted data block, e.g., 8x16 means 8 rows
and each row contains 16 contiguous data element. The rows could be
either contiguous or not, depends on whether the encoding attribute
is set or not.</li><li>element_type: the data type of the data element, e.g., f16, f32.</li></ul><p>Similar to the builtin tensor, it also provides an optinal attribute to encoding
the following information via the TensorDescAttr object:</p><ul><li>memory_scope (xegpu::MemoryScope): [optional] where the data is located,
global memory or shared memory. It is default to Global.</li><li>array_length (int): [optional] The number of contiguous blocks with size as <code>shape</code>,
that will be loaded by block load at a time. It is default to 1.</li><li>boundary_check (bool): [optional] indicates whether the operation detects the boundary
and pads with zero for out-of-boundary access. It is default to do boundary check.</li></ul><p>Syntax:</p><pre tabindex=0><code>TensorDesc-type ::= `tensor_desc` `&lt;` dim-list element-type (attr-list)? `&gt;`
element-type ::= float-type | integer-type | index-type
dim-list := (static-dim-list `x`)?
static-dim-list ::= decimal-literal `x` decimal-literal
attr-list = (, memory_scope = value)? (, arr_len = value)? (, boundary_check = value)? (, scattered = value)?
</code></pre><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// A block TensorDesc with 8x16 i32 elements
</span></span></span><span class=line><span class=cl><span class=c></span>xegpu<span class=p>.</span><span class=kt>tensor</span>_desc<span class=p>&lt;</span><span class=m>8x16x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A block TensorDesc with 8x16 f32 elements
</span></span></span><span class=line><span class=cl><span class=c></span>xegpu<span class=p>.</span><span class=kt>tensor</span>_desc<span class=p>&lt;</span><span class=m>8x16x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A TensorDesc with 8x16 f32 elements for a memory region in shared memory space.
</span></span></span><span class=line><span class=cl><span class=c></span>xegpu<span class=p>.</span><span class=kt>tensor</span>_desc<span class=p>&lt;</span><span class=m>8x16x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#xegpu.tdesc_attr</span><span class=p>&lt;</span><span class=nl>memory_scope =</span> slm<span class=p>&gt;&gt;</span>
</span></span></code></pre></div><h4 id=parameters-4>Parameters:&nbsp;<a class=headline-hash href=#parameters-4>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>shape</td><td style=text-align:center><code>::llvm::ArrayRef&lt;int64_t></code></td><td></td></tr><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>mlir::Attribute</code></td><td></td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/X86Vector/ title="'x86vector' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'x86vector' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/Builtin/ title="Builtin Dialect">Next - Builtin Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Mesh/>'mesh' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PolynomialDialect/>'polynomial' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>